<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">

    <title>Flock</title>
    <link rel="stylesheet" href="res/styles/stylesheet.css">

    <script type="text/javascript" src="lib/paper.js"></script>
    <script type="text/javascript" src="lib/jquery.js"></script>
    <script type="text/javascript" src="js/renderEngine.js"></script>
    <script type="text/javascript" src="js/world.js"></script>
    <script type="text/javascript" src="js/entity.js"></script>

    <script type="text/javascript" >

        paper.install( window );

        var resizeCanvas = function() {
            var c       = $( "#canvas" );
            var cDOM    = c.get(     0 );

            var cWidth  = c.parent().innerWidth()  - 30;
            var cHeight = c.parent().innerHeight() - 30;

            c.css( {

                width:  cWidth  + 'px', 
                height: cHeight + 'px'

            } );

            cDOM.width  =  cWidth;
            cDOM.height = cHeight;

        };

        $(document).ready( resizeCanvas );
        $(window).resize(  resizeCanvas );

        $(document).ready( function(){

            var world  = new World();

            var step   = function () {

                var velocity   = new Point( 0, 0 );

                // Find neighbours
                var neighbours =       new Array();

                var      distance, body, neighbour, awayV;
                var aversion          = new Point( 0, 0 );
                var localCentre       = new Point( 0, 0 );
                var neighboursTooNear =                 0;
                for ( var i = 0; i < this.world.bodies.length; i++ ) {
                    body = this.world.bodies[ i ];

                    distance   = this.position.getDistance(               body.position, false );
                    if ( distance <= this.__threshold && this != body ) {
                        neighbour = body;
                        // Calculate Separation

                        if ( distance <= this.__personal ) {

                            awayV     =       this.position.subtract( neighbour.position );
                            awayV     =           awayV.isZero() ? Point.random() : awayV ;
                            awayV     =                                  awayV.normalize();

                            if( distance < 0.5 ) {
                                awayV = awayV.multiply(                  2 * this.__maxV );
                            } else {
                                awayV = awayV.multiply(           this.__maxV / distance );
                            }

                            aversion  = aversion.add(                              awayV );

                            neighboursTooNear++;
                        }

                        // Calculate centre of group

                        localCentre = localCentre.add(                neighbour.position );

                    }

                }

                if ( neighboursTooNear != 0 ) aversion.divide(       neighboursTooNear );
                if ( neighbours.length != 0 ) localCentre.divide(    neighbours.length );

                var cohesion  = localCentre.subtract(                    this.position );
                cohesion      = Point.min( cohesion, cohesion.normalize( this.__maxV ) );

                var rebound   = new Point();

                if ( this.position.x >  this.world.renderer.canvas.width ) rebound.x =  this.world.renderer.canvas.width - this.position.x
                else if ( this.position.x < 0 )                            rebound.x =                                   - this.position.x;
                else                                                       rebound.x =                                                   0;

                if ( this.position.y > this.world.renderer.canvas.height ) rebound.y = this.world.renderer.canvas.height - this.position.y;
                else if ( this.position.y < 0 )                            rebound.y =                                   - this.position.y;
                else                                                       rebound.y =                                                   0;

                rebound       = rebound.multiply( 2 );

                velocity      = velocity.add(       rebound );
                velocity      = velocity.add(      cohesion );
                velocity      = velocity.add(      aversion );

                this.targetV  =                      velocity;

            };

            var ent;
            for ( i = 0; i < 10; i++ ) {
                ent = new Entity();

                ent.addStepFunction( step );
                world.addEntity(      ent );

            }

            var engine = new RenderEngine( $( "#canvas" ).get( 0 ), world );

        } );

    </script>

</head>

<body>

    <div id="wrapper">
        <div id="name">Flock</div>

        <div id="canvas_wrapper">
            <canvas id="canvas" ></canvas>
        </div>
    </div>
    
</body>

</html>
